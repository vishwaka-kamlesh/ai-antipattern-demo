rules:

  # 1. Truly empty catch blocks (ignores comments, braces, TODOs)
  - id: empty-catch-block
    languages: [java]
    severity: ERROR
    message: Empty catch block swallows exceptions. At minimum log or rethrow.
    pattern: |
      catch ($EX $E) { }

  # 2. printStackTrace() — zero tolerance
  - id: no-print-stacktrace
    languages: [java]
    severity: ERROR
    message: Never use printStackTrace(). Use logger.error("...", e) instead.
    pattern: |
      $E.printStackTrace(...)

  # 3. System.out / System.err — any method call
  - id: no-system-out
    languages: [java]
    severity: ERROR
    message: Use SLF4J logger instead of System.out/err.
    pattern-either:
      - pattern: System.out.$ANY(...)
      - pattern: System.err.$ANY(...)

  # 4. Logging sensitive data — only actual variable interpolation
  - id: logging-sensitive-data
    languages: [java]
    severity: ERROR
    message: Logging sensitive data. Mask before logging (e.g., maskPassword(password)).
    patterns:
      - pattern-either:
          - pattern: logger.$METHOD(..., $VAR, ...)
          - pattern: logger.$METHOD("..." + $VAR + ...)
          - pattern: logger.$METHOD(String.format(..., $VAR, ...), ...)
      - metavariable-regex:
          metavariable: $VAR
          regex: (?i).*(password|passwd|pwd|token|secret|apikey|api_key|clientsecret|client_secret|bearer|cardnumber|card_number|pan|cvv|pin|ssn|social_security).*

  # 5. Hardcoded credentials — real secrets only, exclude test/example patterns
  - id: hardcoded-credentials
    languages: [java]
    severity: ERROR
    message: Hardcoded secret detected. Move to Vault / Config / Secrets Manager.
    patterns:
      - pattern-regex: (?i)(password|passwd|pwd|secret|token|api[_-]?key|client[_-]?secret|bearer)\s*[:=]\s*"[^"{}\s]{8,}"
      - pattern-not-regex: '(?i)(your_|example|placeholder|dummy|test_|fake_|sample|xxx|todo|change|replace)'

  # 6. Hardcoded URLs — only connection/config assignments, exclude docs/examples
  - id: hardcoded-url
    languages: [java]
    severity: ERROR
    message: Hardcoded URL detected. Move to @Value or application.yml/properties.
    patterns:
      - pattern-either:
          - pattern: $TYPE $VAR = "https://...";
          - pattern: $MODIFIER $TYPE $VAR = "https://...";
          - pattern: return "https://...";
      - metavariable-regex:
          metavariable: $VAR
          regex: (?i).*(url|endpoint|host|base|uri|address|service).*
      - pattern-not-regex: '(?i)(localhost|127\.0\.0\.1|0\.0\.0\.0|example\.com|test\.|docs\.|schemas\.|xmlns)'

  # 7. SQL injection via string concatenation — only actual query execution
  - id: sql-injection-concat
    languages: [java]
    severity: ERROR
    message: SQL injection risk via string concatenation. Use QueryDSL, JPA Criteria, or PreparedStatement parameters.
    patterns:
      - pattern-either:
          - pattern: $STMT.executeQuery($Q + ...)
          - pattern: $STMT.execute($Q + ...)
          - pattern: $STMT.executeUpdate($Q + ...)
          - pattern: $JDBC.query($Q + ...)
          - pattern: $JDBC.update($Q + ...)
          - pattern: $JDBC.queryForObject($Q + ...)
          - pattern: $JDBC.queryForList($Q + ...)
          - pattern: $EM.createNativeQuery($Q + ...)
      - metavariable-regex:
          metavariable: $Q
          regex: (?i).*(select|insert|update|delete|from|where).*

  # 8. Thread.sleep — blocks container threads
  - id: no-thread-sleep
    languages: [java]
    severity: ERROR
    message: Thread.sleep() blocks container threads. Use ScheduledExecutorService, @Scheduled, or async processing.
    pattern: Thread.sleep(...)

  # 9. String concatenation in loop — creates excessive objects
  - id: string-concat-in-loop
    languages: [java]
    severity: ERROR
    message: String concatenation in loop creates many temporary objects. Use StringBuilder or Stream.collect(Collectors.joining()).
    patterns:
      - pattern: $S += $X
      - pattern-inside: |
          for (...) {
            ...
          }

  # 10. Expensive object creation in loop — focused on known heavy objects
  - id: expensive-object-in-loop
    languages: [java]
    severity: WARNING
    message: Creating expensive objects inside loop. Consider reusing or moving outside loop.
    patterns:
      - pattern-inside: |
          for (...) {
            ...
          }
      - pattern-either:
          - pattern: new SimpleDateFormat(...)
          - pattern: new DateFormat(...)
          - pattern: Pattern.compile(...)
          - pattern: new ObjectMapper(...)
          - pattern: new Gson(...)
          - pattern: new JsonParser(...)
          - pattern: new SAXParser(...)
          - pattern: new DocumentBuilder(...)
          - pattern: new XPath(...)

  # 11. N+1 query — repository calls and lazy loading in loops
  - id: nplus1-query-detection
    languages: [java]
    severity: ERROR
    message: Potential N+1 query. Use JOIN FETCH, @EntityGraph, or batch fetching.
    patterns:
      - pattern-inside: |
          for ($E : $LIST) {
            ...
          }
      - pattern-either:
          - pattern: $REPO.$METHOD(...)
          - pattern: $E.get$RELATION()
      - metavariable-regex:
          metavariable: $REPO
          regex: .*(Repository|Repo|Dao|DAO)

  # 12. String comparison with == operator
  - id: string-equals-operator
    languages: [java]
    severity: ERROR
    message: Use .equals() or .equalsIgnoreCase() for String comparison, not == or !=.
    pattern-either:
      - pattern: $STR == "..."
      - pattern: '"..." == $STR'
      - pattern: $STR != "..."
      - pattern: '"..." != $STR'

  # 13. DTO/Request/Response with public fields — should be private
  - id: dto-public-fields
    languages: [java]
    severity: ERROR
    message: DTO/Request/Response fields must be private. Use getters/setters, Lombok, or Java records.
    patterns:
      - pattern: public $T $FIELD;
      - pattern-inside: |
          class $NAME {
            ...
          }
      - metavariable-regex:
          metavariable: $NAME
          regex: .*(DTO|Dto|Request|Response|Spec|Specification|VO|Model)$
      - pattern-not: public static final $T $FIELD = ...;

  # 14. Magic numbers — only in assignments, exclude common values
  - id: magic-numbers
    languages: [java]
    severity: WARNING
    message: Replace magic number with named constant (static final) for maintainability.
    patterns:
      - pattern-either:
          - pattern: $VAR = $N;
          - pattern: $METHOD($N)
      - metavariable-regex:
          metavariable: $N
          regex: ^(1[1-9]|[2-9][0-9]|[1-9][0-9]{2,})$
      - pattern-not: $VAR = 200;
      - pattern-not: $VAR = 201;
      - pattern-not: $VAR = 400;
      - pattern-not: $VAR = 401;
      - pattern-not: $VAR = 403;
      - pattern-not: $VAR = 404;
      - pattern-not: $VAR = 500;
      - pattern-not: $VAR = 502;
      - pattern-not: $VAR = 503;
      - pattern-not: $VAR = 8080;
      - pattern-not: $VAR = 8443;
      - pattern-not: $VAR = 3000;
      - pattern-not: $VAR = 5432;
      - pattern-not: $VAR = 3306;
      - pattern-not-inside: |
          static final $TYPE $CONST = ...;
      - pattern-not-inside: |
          enum $E {
            ...
          }

  # 15. Field injection with @Autowired — use constructor injection
  - id: no-field-injection
    languages: [java]
    severity: ERROR
    message: Field injection with @Autowired is discouraged. Use constructor injection for better testability and immutability.
    patterns:
      - pattern: |
          @Autowired
          $TYPE $FIELD;
      - pattern-not: |
          @Value(...)
          $TYPE $FIELD;

  # 17. Resource leak — missing try-with-resources
  - id: resource-leak
    languages: [java]
    severity: ERROR
    message: Resource leak detected. Use try-with-resources for auto-closing (InputStream, Connection, Statement, Reader, etc.).
    patterns:
      - pattern-either:
          - pattern: $RES = new FileInputStream(...);
          - pattern: $RES = new FileOutputStream(...);
          - pattern: $RES = new FileReader(...);
          - pattern: $RES = new FileWriter(...);
          - pattern: $RES = new BufferedReader(...);
          - pattern: $RES = $CONN.createStatement();
          - pattern: $RES = $CONN.prepareStatement(...);
      - pattern-not-inside: |
          try ($RES = ...) {
            ...
          }

  # 18. Null check after dereferencing — logic error
  - id: null-check-after-dereference
    languages: [java]
    severity: ERROR
    message: Null check after dereferencing variable. Move null check before usage to avoid NullPointerException.
    patterns:
      - pattern: |
          $VAR.$METHOD(...);
          ...
          if ($VAR == null) {
            ...
          }

  # 19. Inefficient isEmpty() check
  - id: inefficient-empty-check
    languages: [java]
    severity: WARNING
    message: Use .isEmpty() instead of .size() == 0 or .length() == 0 for better readability and performance.
    pattern-either:
      - pattern: $COLL.size() == 0
      - pattern: $COLL.size() > 0
      - pattern: $STR.length() == 0
      - pattern: $STR.length() > 0

  # 20. Double-checked locking without volatile — concurrency bug
  - id: double-checked-locking-no-volatile
    languages: [java]
    severity: ERROR
    message: Double-checked locking requires 'volatile' keyword to work correctly in Java. Make singleton field volatile.
    patterns:
      - pattern-inside: |
          class $C {
            ...
            $TYPE $INSTANCE;
            ...
          }
      - pattern: |
          if ($INSTANCE == null) {
            synchronized (...) {
              if ($INSTANCE == null) {
                $INSTANCE = ...;
              }
            }
          }
      - pattern-not-inside: |
          class $C {
            ...
            volatile $TYPE $INSTANCE;
            ...
          }

  # 21. Comparison with Boolean.TRUE/FALSE using ==
  - id: boolean-comparison-with-equals
    languages: [java]
    severity: ERROR
    message: Use .equals() when comparing with Boolean.TRUE or Boolean.FALSE, not ==.
    pattern-either:
      - pattern: $VAR == Boolean.TRUE
      - pattern: $VAR == Boolean.FALSE
      - pattern: Boolean.TRUE == $VAR
      - pattern: Boolean.FALSE == $VAR

  # 22. Using Arrays.asList on primitive arrays
  - id: arrays-aslist-primitive
    languages: [java]
    severity: ERROR
    message: Arrays.asList() doesn't work as expected with primitive arrays. Use IntStream, LongStream, or manual conversion.
    pattern: Arrays.asList($ARR)

  # 23. Modifying collection while iterating
  - id: modify-collection-while-iterating
    languages: [java]
    severity: ERROR
    message: Modifying collection during iteration causes ConcurrentModificationException. Use Iterator.remove() or collect to new collection.
    patterns:
      - pattern-inside: |
          for ($E : $COLL) {
            ...
          }
      - pattern-either:
          - pattern: $COLL.remove(...)
          - pattern: $COLL.add(...)

  # 24. BigDecimal created from double
  - id: bigdecimal-from-double
    languages: [java]
    severity: ERROR
    message: Creating BigDecimal from double loses precision. Use BigDecimal.valueOf() or String constructor instead.
    pattern: new BigDecimal($D)

    rules:

  # 1. Empty catch blocks - FIXED with better pattern
  - id: empty-catch-block
    languages: [java]
    severity: ERROR
    message: Empty catch block swallows exceptions. At minimum log or rethrow.
    pattern: |
      catch (...) {
      }

  # 11a. N+1 query - repository calls in loop
  - id: nplus1-query-repository
    languages: [java]
    severity: ERROR
    message: Potential N+1 query - repository call inside loop. Use JOIN FETCH, @EntityGraph, or batch fetching.
    patterns:
      - pattern: |
          for ($E : $LIST) {
            ...
            $REPO.$METHOD(...);
            ...
          }
      - metavariable-regex:
          metavariable: $REPO
          regex: .*(Repository|Repo|repository|repo)

  # 11b. N+1 query - entity getter calls (lazy loading)
  - id: nplus1-query-lazy-loading
    languages: [java]
    severity: ERROR
    message: Potential N+1 query - lazy loading inside loop. Use JOIN FETCH or @EntityGraph to fetch eagerly.
    patterns:
      - pattern: |
          for ($ITEM : $ITEMS) {
            ...
            $ITEM.get$METHOD(...);
            ...
          }
      - metavariable-regex:
          metavariable: $METHOD
          regex: (Orders|Users|Payments|Invoices|Customer|Product|Items|Details|Address|Profile)

  # 23a. Remove from collection while iterating
  - id: modify-collection-while-iterating-remove
    languages: [java]
    severity: ERROR
    message: Removing from collection during iteration causes ConcurrentModificationException. Use Iterator.remove() instead.
    pattern: |
      for ($ITEM : $COLL) {
        ...
        $COLL.remove(...);
        ...
      }

  # 23b. Add to collection while iterating
  - id: modify-collection-while-iterating-add
    languages: [java]
    severity: ERROR
    message: Adding to collection during iteration causes ConcurrentModificationException. Collect to new collection instead.
    pattern: |
      for ($ITEM : $COLL) {
        ...
        $COLL.add(...);
        ...
      }
